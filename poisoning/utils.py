import re
import string
from typing import List


# To avoid length bias, generate varying lengths
# (num_words, max_new_tokens)
LENGTHS_TO_TRY = [
    (10, 32),
    (20, 64),
    (30, 96),
    (40, 128)
]


def text_cleanup(text: str) -> str:
    """
    Cleanup text generated by LLM.
    Removes:
    - >1 consecutive spaces, newlines
    - Leading "Answer:" or "Question:" strings
    - Leading and trailing spaces
    - Leading and trailing newlines
    - Excessive punctuation (e.g., more than 3 dots or exclamation marks)
    - Non-standard whitespace characters (e.g., tabs, non-breaking spaces)
    """
    # Remove leading "Answer:" or "Question:" if present
    text = re.sub(r'^\s*(Answer:|Question:)\s*', '', text, flags=re.IGNORECASE)
    
    # Normalize non-standard whitespace characters to regular spaces
    text = re.sub(r'\s+', ' ', text)

    # Replace excessive punctuation
    text = re.sub(r'[.]{3,}', '...', text)       # Replace more than three dots with "..."
    text = re.sub(r'[!]{2,}', '!', text)         # Replace more than one exclamation mark with "!"
    text = re.sub(r'[?]{2,}', '?', text)         # Replace more than one question mark with "?"

    # Remove excess spaces and newlines
    text = re.sub(r'\n{2,}', '\n', text) # Replace multiple newlines with single newline
    text = re.sub(r'\s{2,}', ' ', text)  # Replace multiple spaces with single space

    # Trim leading/trailing whitespace and newlines
    return text.strip()


def clean_collection(texts: List[str]) -> List[str]:
    """
    Clean up a collection of texts.
    """
    MIN_CHARS = 10
    # Remove duplicates
    texts = list(set(texts))
    # Remove anything with length < MIN_CHARS
    texts = list(filter(lambda x: len(x) >= MIN_CHARS, texts))
    if len(texts) == 0:
        raise ValueError("Cleaning sequence resulted in empty list")
    # TODO: Duplicate removal based on LLM-based deduplication/n-gram based deduplication
    return texts


def remove_non_ascii(text: str) -> str:
    """
    Remove non-ascii characters from text.
    """
    printable = set(string.printable)
    return ''.join(filter(lambda x: x in printable, text))


def wrap_text_for_pipeline(text: str):
    # For Gemma
    # return {"type": "text", "text": text}
    return [{"type": "text", "text": str(text)}]
    # For llama
    # return str(text)
